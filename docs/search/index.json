[{"content":"A distributed system is a coordonated group of machines working towards a common objective but to the end use it appears as if they are tallking to a single machine. The common objective can be the utility and the gurantees the system provides such as database, or a stream processor, a batch processing systems. The true complexity of a distributed system design lies in abstracting out the fact that a client is talking to multiple servers behind the scene and not just one of them. If proper care is taken in how you choose these machines (not sharing the same data-centre rack or even building) carefully, a distributed system can be more highly available than a single machine system. High availbaility comes from having multiple copies of the data and in which case if a machine fails you can get the data from other machines and this must happen transparently for the client. Now, if any replica is capable if serving the requested data, then they must all have the latest version of the data. This is the core of the problem, keeping all copies of the data consistent in face of machine failures or network partitions.\nPutting the problem simply, a distributed systems designer has to wrestle with these four questions - how to deal with writes, which machine should handle the read, how to detect failures and then how to recover from them. All of these are error prone and therefore we want to have enough confidence in our design. There are a few ways we can do that:\n Write tests. Util tests and integration tests are a good place to start but they only help us catch issues that we already anticipate. There are frameworks like proptest that help to test whether certain properties of your code hold for an arbitrary set of input and if the code fails, the framework provides a counter-example to the hypothesis. This is great but does not guarantee that it will find all the faliure scenarios. We can subject our system to Jepsen Analysis or their new tool Elle[2]. This generates the system traces and then does an analysis for database consistency violations. This is quite rigorous but again, does not gurantee all the edge cases will be explored. Exernal fault injection with frameworks such as Chaos Monkey. Have exhaustive logs, metrics and traces (the three pillars of Observability). This helps you catch bugs after the fact but does not prevent the occurrence of it. It is also based on the premise that we have sufficient logging enabled around the failure path. Write a simulator for your system before doinf the actual implementation as the FoundationDB folks did. Formal methods based on model checking (exhaustively exploring the state space) or formal verification can generate machine checked proof of the system spec but its very hard to generate the full specification of a system. Systems are complex and they evolve with new features. Its tedious to keep the spec up to date. Another problem is that the spec is maintained separately from the code.  Although the above points might be disheartening, we would still like to write correct distributed systems. And there are ways we can do it. As IronFleet[1] established, it is possible to verify a complex paxos-based Replicaed State Machine and use it to implement a shared Key/value store. When you read the paper you realize that one of the hardest part might have been to come up with the invariants in the\nWriting a system Specification As Butler Lampson writes in this paper, the writing of a correct system should always begin at the Specification. There are tools that can help you write one such as $TLA^+$ that can reason about Temperal Logic and proof assistants such as Coq. The problem with this approach is that the spec and the code are maintained separately and the spec is only for documentation only. Writing a correct spec does not gurantee a correct implementation as there is no system that validates the implementaiton against the proof of correctness. Think of this like a compiler for a language. I compiler writer decides the syntax of the language and then writes a compiler that accepts programs within the bounds of what the language specification allows. The compiler usually does it in a hands-free manner but there are cases where the programmer needs to lead the compiler by hand such as when we have to specify the lifetimes in a rust program explicitly.\nIn case of distributed system spec, we want to provide the designer the freedom to come up with the rules of the system. This is important, because we want our spec writing framework to be used with a wide variety of systems and not just one. There are verifiers such as Dafny and Prusti that takes specifications as code annotations sprinkled over functions as pre and post conditions. This is consistent wiith the Floyd-Hoare Logic which talks about a $3-tuple$ ${P}$C${Q}$ where P and Q are assertions also called the pre-condition (restrictions on input written as assertions in predicate logic) and post-conditions (restrictions on output also described as assertions in predicate logic) and $C$ is the command to be executed when the pre-conditions are met generating values consistent with the post-conditions. It is important for the spec to be contained in a module of its own. Having it sprinkled all over can make it hard to read in a large codebase of several million lines which is a commonplace for distributed systems. I would like to think of the spec to be written in a custom DSL in a few .spec files. In Rust lingo, the spec should be in a separate crate and building a spec should generate dummy top level Protocol stubs with annotations for pre and post conditions.\nVerifying the Spec The spec format should be very close to Rust format but it should be expressive enough for people to encode the proof Hypothesis and the goal. The goal of a verification tool is given this situation, prove that the constraint holds for all input values and if they don\u0026rsquo;t, then provide a counter example. And then the spec author can tune the invariants and put it up for another round of evaluation against the verification tool and this is repeated.\nThe Mikino Bounded Model Checker does a great job is staying close to Rust Syntax.\n// The scenario models a stop-watch with a toggle button which can be /// pressed to toggle between start and stop. Whether the stop-watch is /// in counting mode or stopped is indicated by the is_counting state /// variable. And the value of the counter is provided by the counter. /// Reset button sets the counter to 0. /// State variables. svars{/// Inputs of the system. start_stopreset: bool,/// Keeps track of whether we are counting. is_counting: bool,/// Counts time, output of the system. cnt: int,}/// Initial state of the system. init{is_counting=start_stop,cnt≥0,(reset⇒cnt=0),}/// Transition relation. trans{// The *next* value of `is_counting` is equal to... \u0026#39;is_counting=if\u0026#39;start_stop{// ...if `\u0026#39;start_stop` is true, then the negation of // its *previous* value... ¬is_counting}else{// ...otherwise, it is equal to its previous value. is_counting},\u0026#39;cnt=if\u0026#39;reset{0}elseif\u0026#39;is_counting{cnt+1}else{cnt},}/// State invariants. candidates{\u0026#34;cnt is positive\u0026#34;: cnt≥0,\u0026#34;cnt ≤ 2\u0026#34;: cnt≤2,\u0026#34;cnt ≤ 4\u0026#34;: cnt≤4,}Mikino uses the venerable Z3 solver to solve for constraints. Ze has a Rust adapter that can be used here.\nAnother example is the Stateright which is written in Rust and the Model provided as Rust struct that implements the Actor trait. The following is an example copied from the stateright repo depicting the state transitions in a Linearizable Registers from the paper Sharing Memory Robustly in Message-Passing Systems by Attiya, Bar-Noy, and Dolev (ABD).\n.../// State variables to capture of Linearizable #[derive(Clone, Debug, Eq, Hash, PartialEq)]pubstruct AbdState{seq: Seq,val: Value,phase: Option\u0026lt;AbdPhase\u0026gt;,}...implActorforAbdActor{type Msg=RegisterMsg\u0026lt;RequestId,Value,AbdMsg\u0026gt;;type State=AbdState;/// Initial state fn on_start(\u0026amp;self,id: Id,_o: \u0026amp;mutOut\u0026lt;Self\u0026gt;)-\u0026gt; Self::State{AbdState{seq: (0,id),val: Value::default(),phase: None,}}/// State transition on receiving messages. fn on_msg(\u0026amp;self,id: Id,state: \u0026amp;mutCow\u0026lt;Self::State\u0026gt;,src: Id,msg: Self::Msg,o: \u0026amp;mutOut\u0026lt;Self\u0026gt;){matchmsg{Put(req_id,val)ifstate.phase.is_none()=\u0026gt;{o.broadcast(\u0026amp;self.peers,\u0026amp;Internal(Query(req_id)));state.to_mut().phase=Some(AbdPhase::Phase1{request_id: req_id,requester_id: src,write: Some(val),responses: {letmutresponses=HashableHashMap::default();responses.insert(id,(state.seq,state.val.clone()));responses},});}Get(req_id)ifstate.phase.is_none()=\u0026gt;{o.broadcast(\u0026amp;self.peers,\u0026amp;Internal(Query(req_id)));state.to_mut().phase=Some(AbdPhase::Phase1{request_id: req_id,requester_id: src,write: None,responses: {letmutresponses=HashableHashMap::default();responses.insert(id,(state.seq,state.val.clone()));responses},});}...Stateright does not verify the Model or any arbitrary but acceptable input but it can validate the a trace for you. This is closer to how Jepsen works. You run a workload against the system and capture the trace and then you pass the trace to your checker and it can tell you if there is a possible falsification of the claimed consistency level of the system. But as one might guess, this method validates only the given trace and not all possible traces.\n\rThe flow from I4[5]\r\nThe state invariants are the hardest thing ting to get right and in the workflow depicted above from the I4 paper[5] shows a way.\nLevels Of Refinements \rScreen Shot 2021-10-10 at 8.56.54 PM\r\n References   IronFleet, SOSP' 2015\n  Elle, VLDB 2021\n  Lineage Dtiven Fault Injection, SIGMOD 2015\n  HandBook Of Model Checking.\n  I4, SOSP 2019.\n  Verdi, PLDI 2015.\n  Ivy.\n  Hints and Principles of System Design.\n  ","date":"2021-10-12T00:00:00Z","image":"https://distributed-randomness.github.io/p/the-tale-of-the-iron-born/yellow_swirl_hu3b2749d1cdf724aabc7cbad8108c554b_6067644_120x120_fill_q75_box_smart1.jpg","permalink":"https://distributed-randomness.github.io/p/the-tale-of-the-iron-born/","title":"The tale of the Iron Born"},{"content":"","date":"2021-10-10T00:00:00Z","image":"https://distributed-randomness.github.io/p/my-second-post/strings_hua101d5b344ef02f0d7f177865409a803_1692058_120x120_fill_q75_box_smart1.jpg","permalink":"https://distributed-randomness.github.io/p/my-second-post/","title":"My second post"}]